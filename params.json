{"name":"Jill","tagline":"","body":"# Who, is Jill?\r\n\r\nOr rather, what. Jill is a fast, scalable, and lightweight execution engine, written in Java, for programming cognitive agents in the BDI tradition.\r\n\r\nSay what? \r\n\r\nOkay, if you know object oriented programming, then we are talking about its newer cousin called [agent-oriented programming](https://en.wikipedia.org/wiki/Agent-oriented_programming), which loosely fits within the field of [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence) research. That's a paradigm shift for the programmer, just like object-oriented programming was compared to structural programming before that. So replace objects with agents, fields with beliefs, and methods with plans, and you're half way there. \r\n\r\n## What is BDI?\r\n\r\nBDI programming is a style of agent oriented programming. BDI, which stands for Belief-Desire-Intention, is a cognitive framework for implementing practical reasoning in computer programs. It has its roots in philosophy, and is based on [Bratman's](https://philosophy.stanford.edu/people/michael-bratman) theory of human practical reasoning and [Dennett's](https://en.wikipedia.org/wiki/Daniel_Dennett) theory of intentional systems. A BDI agent is characterised by an informational state (*beliefs*) about the world, a motivational state (*desires*) or objectives in the world, and a deliberative state (*intentions*) or commitments that are current in the world. It uses these mental attitudes to rationalise its actions, much like humans do (that last part is debatable). \r\n\r\nConceptually, BDI programs achieve their goals and react to different situations by matching pre-programmed abstract recipes, or *plans*, to the situation. For example, a programmer may provide two plans that could be used to get to work. While one plan may involve cycling to work, the other may require catching the bus. Which one of these will be used by the agent will depend on the situation, such as whether the agent believes it is going to rain or not. BDI agent systems are particularly well suited for dynamic environments where enabling conditions for a course of action can change quickly.\r\n\r\nThere is a nice overview of BDI systems in Chapter 2 of [my PhD thesis](https://researchbank.rmit.edu.au/eserv/rmit:160114/Singh.pdf), if you want a quick tour of BDI concepts and research in the last two decades.  \r\n\r\n## Why Jill?\r\n\r\nA plethora of BDI systems exist already, we hear you say. [JACK](http://aosgrp.com/products/jack/). [Jadex](http://www.activecomponents.org/bin/view/About/Features). [Jason](http://jason.sourceforge.net/wp/). And [friends](https://en.wikipedia.org/wiki/Belief%E2%80%93desire%E2%80%93intention_software_model#BDI_agent_implementations). So why do we need yet-another-BDI-engine? We should have called it Y-a-b-e anyway, you add.\r\n\r\nThat's a fair question. When we started integrating cognitive (BDI) agents with [social (agent-based) simulations](https://en.wikipedia.org/wiki/Social_simulation), we happily used the existing systems for many years. In fact, we still maintain and use an integration framework we developed, for coupling off-the-shelf BDI systems (like [JACK](http://aosgrp.com/products/jack/) and [Jadex](http://www.activecomponents.org/bin/view/About/Features)), with off-the-shelf ABMs (like [Repast](repast.sourceforge.net), and [MATSim](www.matsim.org).) \r\n\r\nEventually, however, we started hitting a bottleneck as we began playing with larger simulations. Most existing BDI systems are just not built for scale. So over the years, we drew up our specifications. We wanted something scalable, fast, lightweight, open-source, extendible, and Java-based. We wanted a million BDI agents. Running on our not-so-state-of-the-art laptops with 2 GB of RAM. \r\n\r\nSo out in the [outback](https://en.wikipedia.org/wiki/Outback), Jill was born. Now she is old enough to join the playground.\r\n\r\n## Why Java?\r\n\r\nRewind. Did we say *fast*, *scalable*, and *Java* all in the same breath? Surely, if we are talking optimised code, then Java is not the best choice? Wouldn't one want a native program and not something that runs within the Java Virtual Machine? Wouldn't the Java Garbage Collector kill performance before one could say, *cheese and crackers*? \r\n \r\nWe don't disagree. These are real concerns. Indeed, C or C++ for instance, might be better candidates. However, here's the thing. In the end, Jill wasn't to live in a void. By design, we wanted something that could be easily plugged into agent-based simulation platforms. Incidentally, many of our target platforms (like Repast, MATSim, NetLogo) live in a Java ecosystem. While it is possible for native programs to interact with Java through the Java Native Interface, Java-Native calls have insignificant overheads, and a poorly designed interface could easily kill any benefits of the native program. It also makes the entire development process slower, since one has to then consider OS specific issues in the entire life cycle. Plus we wanted the user set up to be as simple as possible. Drop in the JAR file, and [Jill's your aunt](https://en.wikipedia.org/wiki/Bob%27s_your_uncle).\r\n\r\nSo in the end it was a strategic decision more than anything else, to use Java. That said, Jill is no [Echidna](https://en.wikipedia.org/wiki/Echidna) either, [Emu](https://en.wikipedia.org/wiki/Emu) more like, and outruns its friends when it comes to performance.\r\n\r\n## What's the catch?\r\n\r\nNothing really, other than that Jill is still young. She is everyone's baby sister, and does not have all the advanced features of the big boys yet. But she is developing fast, and what she does she does pretty well.\r\n\r\n# How do I use it?\r\n\r\nIn a nutshell, you put the Jill release JAR on your classpath, and start coding. The programs you write are still Java programs, but you extend the agent specific classes that Jill provides and add Java annotations to your code so Jill knows how all the elements of your agent program fit together.\r\n\r\nJill is available from [Maven's Central Repository](http://search.maven.org/). We assume you know how to use maven, but if not, here is a [five minute tutorial](https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html). To use Jill, just add the dependency to your `pom.xml`.\r\n\r\n    <dependencies>\r\n        ...\r\n        <dependency>\r\n            <groupId>io.github.agentsoz</groupId>\r\n            <artifactId>jill</artifactId>\r\n            <version>0.2.2</version>\r\n        </dependency>\r\n        ...\r\n    </dependencies>\r\n\r\nThat's it. You're ready to write your first agent program in Jill. Let's to that now.. (*to be continued*).\r\n\r\n \r\n# Contact\r\n\r\nFor more information contact Dhirendra Singh (@dhixsingh).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}